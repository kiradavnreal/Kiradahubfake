local Players = game:GetService("Players")
local UserInputService = game:GetService("UserInputService")
local RunService = game:GetService("RunService")
local TweenService = game:GetService("TweenService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Terrain = workspace:WaitForChild("Terrain")
local HttpService = game:GetService("HttpService")

local player = Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()
local humanoid = character:WaitForChild("Humanoid", 5)
local rootPart = character:WaitForChild("HumanoidRootPart", 5)

if not humanoid or not rootPart then
    warn("Kh√¥ng t√¨m th·∫•y Humanoid ho·∫∑c HumanoidRootPart!")
    return
end
local ScreenGui = Instance.new("ScreenGui")
ScreenGui.Name = "KiradaHalloween"
ScreenGui.Parent = player.PlayerGui
ScreenGui.ResetOnSpawn = false
ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling

local halloweenSound = Instance.new("Sound")
halloweenSound.SoundId = "rbxassetid://1839246711"
halloweenSound.Looped = true
halloweenSound.Volume = 0.5
halloweenSound.Parent = workspace
halloweenSound:Play()

local toggleButton = Instance.new("ImageButton")
toggleButton.Size = UDim2.new(0, 60, 0, 60)
toggleButton.Position = UDim2.new(0, 10, 0, 10)
toggleButton.BackgroundColor3 = Color3.fromRGB(139, 0, 0)
toggleButton.Image = "rbxassetid://89326205091486"
toggleButton.Parent = ScreenGui
toggleButton.Name = "ToggleButton"

local toggleCorner = Instance.new("UICorner")
toggleCorner.CornerRadius = UDim.new(0, 15)
toggleCorner.Parent = toggleButton

local mainFrame = Instance.new("Frame")
mainFrame.Size = UDim2.new(0, 400, 0, 300)
mainFrame.Position = UDim2.new(0.5, -200, 0.5, -150)
mainFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
mainFrame.BackgroundTransparency = 0.5
mainFrame.BorderSizePixel = 0
mainFrame.Visible = false
mainFrame.Parent = ScreenGui

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 12)
mainCorner.Parent = mainFrame

local gradient = Instance.new("UIGradient")
gradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 10))
})
gradient.Rotation = 45
gradient.Parent = mainFrame

local scrollingFrame = Instance.new("ScrollingFrame")
scrollingFrame.Size = UDim2.new(1, 0, 1, 0)
scrollingFrame.Position = UDim2.new(0, 0, 0, 0)
scrollingFrame.BackgroundTransparency = 1
scrollingFrame.BorderSizePixel = 0
scrollingFrame.ScrollBarThickness = 8
scrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(139, 0, 0)
scrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 550)
scrollingFrame.ScrollingDirection = Enum.ScrollingDirection.Y
scrollingFrame.Parent = mainFrame
local fishingFrame = Instance.new("Frame")
fishingFrame.Size = UDim2.new(0, 200, 0, 120)
fishingFrame.Position = UDim2.new(0.5, -100, 0.5, -60)
fishingFrame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
fishingFrame.BackgroundTransparency = 0.5
fishingFrame.BorderSizePixel = 0
fishingFrame.Visible = false
fishingFrame.Parent = ScreenGui

local fishingCorner = Instance.new("UICorner")
fishingCorner.CornerRadius = UDim.new(0, 12)
fishingCorner.Parent = fishingFrame

local fishingGradient = Instance.new("UIGradient")
fishingGradient.Color = ColorSequence.new({
    ColorSequenceKeypoint.new(0, Color3.fromRGB(30, 30, 30)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(10, 10, 10))
})
fishingGradient.Rotation = 45
fishingGradient.Parent = fishingFrame
local titleLabel = Instance.new("TextLabel")
titleLabel.Size = UDim2.new(0, 380, 0, 40)
titleLabel.Position = UDim2.new(0, 10, 0, 10)
titleLabel.BackgroundTransparency = 1
titleLabel.TextColor3 = Color3.fromRGB(139, 0, 0)
titleLabel.Text = "üéÉ Kirada Halloween (beta 1.3) üéÉ"
titleLabel.TextScaled = true
titleLabel.Font = Enum.Font.SourceSansBold
titleLabel.Parent = scrollingFrame

local speedButton = createButton("SpeedButton", UDim2.new(0, 10, 0, 60), "ƒê·∫∑t T·ªëc ƒê·ªô", scrollingFrame)
local speedInput = createTextBox("SpeedInput", UDim2.new(0, 140, 0, 60), "T·ªëc ƒë·ªô (VD: 100)")
local jumpButton = createButton("JumpButton", UDim2.new(0, 270, 0, 60), "ƒê·∫∑t Nh·∫£y", scrollingFrame)

local jumpInput = createTextBox("JumpInput", UDim2.new(0, 10, 0, 110), "Nh·∫£y (VD: 50)")
local teleportButton = createButton("TeleportButton", UDim2.new(0, 140, 0, 110), "D·ªãch Chuy·ªÉn", scrollingFrame)
local teleportInput = createTextBox("TeleportInput", UDim2.new(0, 270, 0, 110), "T√™n ng∆∞·ªùi ch∆°i")

local noclipToggle = createButton("NoclipToggle", UDim2.new(0, 10, 0, 160), "Xuy√™n T∆∞·ªùng: T·∫ÆT", scrollingFrame)
local antiAfkToggle = createButton("AntiAfkToggle", UDim2.new(0, 140, 0, 160), "Anti-AFK: T·∫ÆT", scrollingFrame)
local fishingToggle = createButton("FishingToggle", UDim2.new(0, 270, 0, 160), "C√¢u C√°: T·∫ÆT", scrollingFrame)

local waterWalkToggle = createButton("WaterWalkToggle", UDim2.new(0, 10, 0, 210), "ƒêi Tr√™n N∆∞·ªõc: T·∫ÆT", scrollingFrame)
local flyToggle = createButton("FlyToggle", UDim2.new(0, 140, 0, 210), "Bay: T·∫ÆT", scrollingFrame)
local infiniteJumpToggle = createButton("InfiniteJumpToggle", UDim2.new(0, 270, 0, 210), "Nh·∫£y V√¥ H·∫°n: T·∫ÆT", scrollingFrame)

local killAuraToggle = createButton("KillAuraToggle", UDim2.new(0, 10, 0, 260), "Kill Aura: T·∫ÆT", scrollingFrame)
local killAuraRangeInput = createTextBox("KillAuraRangeInput", UDim2.new(0, 140, 0, 260), "T·∫ßm xa (VD: 20)")
local nearestChestButton = createButton("NearestChestButton", UDim2.new(0, 270, 0, 260), "D·ªãch ƒê·∫øn R∆∞∆°ng G·∫ßn", scrollingFrame)

local bypassFishButton = createButton("BypassFishButton", UDim2.new(0, 10, 0, 20), "Bypass C√°", fishingFrame)
local autoFishButton = createButton("AutoFishButton", UDim2.new(0, 10, 0, 70), "C√¢u C√° BTh", fishingFrame)
local isNoClip = false
local isFishing = false
local isBypassFishing = false
local isAutoFishing = false
local isFlying = false
local isAntiAfk = false
local isWaterWalk = false
local isInfiniteJump = false
local isKillAura = false
local customWalkSpeed = 16
local customJumpPower = 50
local killAuraRange = 20
local noclipConnection = nil
local fishingConnection = nil
local waterWalkConnection = nil
local waterPlatform = nil
local antiAfkConnection = nil
local infiniteJumpConnection = nil
local killAuraConnection = nil
toggleButton.MouseButton1Click:Connect(function()
    mainFrame.Visible = not mainFrame.Visible
    if mainFrame.Visible then
        TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {Position = UDim2.new(0.5, -200, 0.5, -150)}):Play()
        halloweenSound:Play()
    else
        TweenService:Create(mainFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {Position = UDim2.new(0.5, -200, 1, 0)}):Play()
        halloweenSound:Stop()
    end
end)

UserInputService.InputBegan:Connect(function(input, gameProcessed)
    if not gameProcessed and input.KeyCode == Enum.KeyCode.M then
        toggleButton.MouseButton1Click:Fire()
    end
end)
speedButton.MouseButton1Click:Connect(function()
    local success, result = pcall(function()
        local speed = tonumber(speedInput.Text)
        if speed then
            customWalkSpeed = math.clamp(speed, 0, 500)
            if humanoid then
                humanoid.WalkSpeed = customWalkSpeed
                task.wait(math.random(0.1, 0.3))
            end
            notify("ƒê√£ ƒë·∫∑t t·ªëc ƒë·ªô: " .. customWalkSpeed)
        else
            notify("Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho t·ªëc ƒë·ªô!")
        end
    end)
    if not success then
        notify("L·ªói khi ƒë·∫∑t t·ªëc ƒë·ªô: " .. tostring(result))
    end
end)
jumpButton.MouseButton1Click:Connect(function()
    local success, result = pcall(function()
        local jumpPower = tonumber(jumpInput.Text)
        if jumpPower then
            customJumpPower = math.clamp(jumpPower, 0, 250)
            if humanoid then
                humanoid.UseJumpPower = true
                humanoid.JumpPower = customJumpPower
                task.wait(math.random(0.1, 0.3))
            end
            notify("ƒê√£ ƒë·∫∑t s·ª©c nh·∫£y: " .. customJumpPower)
        else
            notify("Vui l√≤ng nh·∫≠p s·ªë h·ª£p l·ªá cho s·ª©c nh·∫£y!")
        end
    end)
    if not success then
        notify("L·ªói khi ƒë·∫∑t s·ª©c nh·∫£y: " .. tostring(result))
    end
end)
local speedJumpConnection
speedJumpConnection = RunService.Heartbeat:Connect(function()
    if character and humanoid then
        pcall(function()
            humanoid.WalkSpeed = customWalkSpeed
            humanoid.JumpPower = customJumpPower
        end)
    else
        if speedJumpConnection then
            speedJumpConnection:Disconnect()
            speedJumpConnection = nil
        end
    end
end)
teleportButton.MouseButton1Click:Connect(function()
    local success, result = pcall(function()
        local targetName = teleportInput.Text
        local targetPlayer = nil
        for _, p in pairs(Players:GetPlayers()) do
            if p.Name:lower():find(targetName:lower()) then
                targetPlayer = p
                break
            end
        end
        if targetPlayer and targetPlayer.Character and targetPlayer.Character:FindFirstChild("HumanoidRootPart") then
            local distance = (rootPart.Position - targetPlayer.Character.HumanoidRootPart.Position).Magnitude
            if distance > 5000 then
                notify("Kho·∫£ng c√°ch d·ªãch chuy·ªÉn qu√° xa!")
                return
            end
            rootPart.CFrame = targetPlayer.Character.HumanoidRootPart.CFrame + Vector3.new(0, 0, 2)
            task.wait(math.random(0.2, 0.5))
            notify("ƒê√£ d·ªãch chuy·ªÉn ƒë·∫øn: " .. targetPlayer.Name)
        else
            notify("Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi ch∆°i ho·∫∑c t√™n kh√¥ng h·ª£p l·ªá!")
        end
    end)
    if not success then
        notify("L·ªói khi d·ªãch chuy·ªÉn: " .. tostring(result))
    end
end)
noclipToggle.MouseButton1Click:Connect(function()
    isNoClip = not isNoClip
    noclipToggle.Text = "Xuy√™n T∆∞·ªùng: " .. (isNoClip and "B·∫¨T" or "T·∫ÆT")
    
    if isNoClip then
        noclipConnection = RunService.Stepped:Connect(function()
            if character and humanoid and rootPart then
                pcall(function()
                    for _, part in pairs(character:GetDescendants()) do
                        if part:IsA("BasePart") then
                            part.CanCollide = false
                        end
                    end
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                end)
            end
        end)
        notify("ƒê√£ b·∫≠t Xuy√™n T∆∞·ªùng")
    else
        if noclipConnection then
            noclipConnection:Disconnect()
            noclipConnection = nil
        end
        if character then
            pcall(function()
                for _, part in pairs(character:GetDescendants()) do
                    if part:IsA("BasePart") then
                        part.CanCollide = true
                    end
                end
            end)
        end
        notify("ƒê√£ t·∫Øt Xuy√™n T∆∞·ªùng")
    end
end)
antiAfkToggle.MouseButton1Click:Connect(function()
    isAntiAfk = not isAntiAfk
    antiAfkToggle.Text = "Anti-AFK: " .. (isAntiAfk and "B·∫¨T" or "T·∫ÆT")
    
    if isAntiAfk then
        antiAfkConnection = RunService.Heartbeat:Connect(function()
            if tick() % 300 < 0.1 then
                pcall(function()
                    game:GetService("VirtualUser"):ClickButton1(Vector2.new(math.random(0, 100), math.random(0, 100)))
                    task.wait(math.random(0.5, 1.5))
                    notify("Anti-AFK: ƒê√£ m√¥ ph·ªèng nh·∫•n chu·ªôt!")
                end)
            end
        end)
        notify("ƒê√£ b·∫≠t Anti-AFK")
    else
        if antiAfkConnection then
            antiAfkConnection:Disconnect()
            antiAfkConnection = nil
        end
        notify("ƒê√£ t·∫Øt Anti-AFK")
    end
end)
waterWalkToggle.MouseButton1Click:Connect(function()
    isWaterWalk = not isWaterWalk
    waterWalkToggle.Text = "ƒêi Tr√™n N∆∞·ªõc: " .. (isWaterWalk and "B·∫¨T" or "T·∫ÆT")
    
    if isWaterWalk then
        waterPlatform = Instance.new("Part")
        waterPlatform.Size = Vector3.new(10, 0.5, 10)
        waterPlatform.Transparency = 0.8
        waterPlatform.BrickColor = BrickColor.new("Really black")
        waterPlatform.CanCollide = true
        waterPlatform.Anchored = true
        waterPlatform.Parent = workspace
        waterPlatform.Name = generateRandomName(10)
        
        waterWalkConnection = RunService.Stepped:Connect(function()
            if character and rootPart and humanoid then
                local rayParams = RaycastParams.new()
                rayParams.FilterDescendantsInstances = {character, waterPlatform}
                rayParams.FilterType = Enum.RaycastFilterType.Exclude
                local ray = workspace:Raycast(rootPart.Position, Vector3.new(0, -10, 0), rayParams)
                
                local isOnWater = false
                local waterY = nil
                local cell = Terrain:WorldToCell(rootPart.Position)
                if Terrain:GetMaterialVoxels(cell.X, cell.Y, cell.Z).Material == Enum.Material.Water then
                    isOnWater = true
                    waterY = cell.Y * 4 + Terrain.WaterLevel
                elseif ray and ray.Instance and (ray.Instance.Name:lower():find("water") or ray.Instance.Name:lower():find("sea") or ray.Instance.Name:lower():find("ocean")) then
                    isOnWater = true
                    waterY = ray.Position.Y
                end
                
                if isOnWater and waterY then
                    waterPlatform.Position = Vector3.new(rootPart.Position.X, waterY + 0.25, rootPart.Position.Z)
                    rootPart.Position = Vector3.new(rootPart.Position.X, waterY + 3, rootPart.Position.Z)
                    humanoid:ChangeState(Enum.HumanoidStateType.Running)
                    humanoid.Sit = false
                else
                    waterPlatform.Position = Vector3.new(0, -1000, 0)
                end
            end
        end)
        notify("ƒê√£ b·∫≠t ƒêi Tr√™n N∆∞·ªõc")
    else
        if waterWalkConnection then
            waterWalkConnection:Disconnect()
            waterWalkConnection = nil
        end
        if waterPlatform then
            waterPlatform:Destroy()
            waterPlatform = nil
        end
        notify("ƒê√£ t·∫Øt ƒêi Tr√™n N∆∞·ªõc")
    end
end)
fishingToggle.MouseButton1Click:Connect(function()
    isFishing = not isFishing
    fishingToggle.Text = "C√¢u C√°: " .. (isFishing and "B·∫¨T" or "T·∫ÆT")
    
    if isFishing then
        fishingFrame.Visible = true
        TweenService:Create(fishingFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {Position = UDim2.new(0.5, -100, 0.5, -60)}):Play()
        notify("ƒê√£ b·∫≠t menu C√¢u C√°")
    else
        fishingFrame.Visible = false
        TweenService:Create(fishingFrame, TweenInfo.new(0.3, Enum.EasingStyle.Back), {Position = UDim2.new(0.5, -100, 1, 0)}):Play()
        isBypassFishing = false
        isAutoFishing = false
        if fishingConnection then
            fishingConnection:Disconnect()
            fishingConnection = nil
        end
        notify("ƒê√£ t·∫Øt C√¢u C√°")
    end
end)

bypassFishButton.MouseButton1Click:Connect(function()
    if not isFishing then return end
    isBypassFishing = not isBypassFishing
    isAutoFishing = false
    bypassFishButton.Text = "Bypass C√°: " .. (isBypassFishing and "B·∫¨T" or "T·∫ÆT")
    autoFishButton.Text = "C√¢u C√° BTh: T·∫ÆT"
    
    if isBypassFishing then
        if fishingConnection then
            fishingConnection:Disconnect()
            fishingConnection = nil
        end
        fishingConnection = RunService.Heartbeat:Connect(function()
            if character and humanoid then
                pcall(function()
                    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
                        if v:IsA("RemoteEvent") and v.Name:lower():find("fish") then
                            v:FireServer("Caught")
                            task.wait(math.random(0.2, 0.6))
                        end
                    end
                    for _, v in pairs(workspace:GetDescendants()) do
                        if v:IsA("RemoteEvent") and v.Name:lower():find("fish") then
                            v:FireServer("Caught")
                            task.wait(math.random(0.2, 0.6))
                        end
                    end
                end)
            end
        end)
        notify("ƒê√£ b·∫≠t Bypass C√°")
    else
        if fishingConnection then
            fishingConnection:Disconnect()
            fishingConnection = nil
        end
        notify("ƒê√£ t·∫Øt Bypass C√°")
    end
end)

autoFishButton.MouseButton1Click:Connect(function()
    if not isFishing then return end
    isAutoFishing = not isAutoFishing
    isBypassFishing = false
    autoFishButton.Text = "C√¢u C√° BTh: " .. (isAutoFishing and "B·∫¨T" or "T·∫ÆT")
    bypassFishButton.Text = "Bypass C√°: T·∫ÆT"
    
    if isAutoFishing then
        if fishingConnection then
            fishingConnection:Disconnect()
            fishingConnection = nil
        end
        fishingConnection = RunService.Heartbeat:Connect(function()
            if character and humanoid then
                pcall(function()
                    for _, v in pairs(ReplicatedStorage:GetDescendants()) do
                        if v:IsA("RemoteEvent") and v.Name:lower():find("cast") then
                            v:FireServer()
                            task.wait(math.random(1.8, 2.8))
                            if v.Name:lower():find("reel") then
                                v:FireServer()
                            end
                        end
                    end
                    for _, v in pairs(workspace:GetDescendants()) do
                        if v:IsA("RemoteEvent") and v.Name:lower():find("cast") then
                            v:FireServer()
                            task.wait(math.random(1.8, 2.8))
                            if v.Name:lower():find("reel") then
                                v:FireServer()
                            end
                        end
                    end
                end)
            end
        end)
        notify("ƒê√£ b·∫≠t C√¢u C√° B√¨nh Th∆∞·ªùng")
    else
        if fishingConnection then
            fishingConnection:Disconnect()
            fishingConnection = nil
        end
        notify("ƒê√£ t·∫Øt C√¢u C√° B√¨nh Th∆∞·ªùng")
    end
end)
infiniteJumpToggle.MouseButton1Click:Connect(function()
    isInfiniteJump = not isInfiniteJump
    infiniteJumpToggle.Text = "Nh·∫£y V√¥ H·∫°n: " .. (isInfiniteJump and "B·∫¨T" or "T·∫ÆT")
    
    if isInfiniteJump then
        infiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
            if character and humanoid then
                pcall(function()
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(math.random(0.1, 0.2))
                end)
            end
        end)
        notify("ƒê√£ b·∫≠t Nh·∫£y V√¥ H·∫°n")
    else
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
            infiniteJumpConnection = nil
        end
        notify("ƒê√£ t·∫Øt Nh·∫£y V√¥ H·∫°n")
    end
end)
flyToggle.MouseButton1Click:Connect(function()
    isFlying = not isFlying
    flyToggle.Text = "Bay: " .. (isFlying and "B·∫¨T" or "T·∫ÆT")
    
    if isFlying then
        for i = 3, 1, -1 do
            notify("B·∫≠t Bay trong: " .. i .. " gi√¢y")
            task.wait(1)
        end
        local success, result = pcall(function()
            return loadstring(game:HttpGet("https://raw.githubusercontent.com/kiradavnreal/Kiradafly/main/Kiradafly.lua"))()
        end)
        if success then
            notify("ƒê√£ b·∫≠t ch·ª©c nƒÉng Bay")
        else
            notify("L·ªói khi t·∫£i script Bay: " .. tostring(result))
            isFlying = false
            flyToggle.Text = "Bay: T·∫ÆT"
        end
    else
        notify("ƒê√£ t·∫Øt ch·ª©c nƒÉng Bay")
    end
end)
killAuraToggle.MouseButton1Click:Connect(function()
    isKillAura = not isKillAura
    killAuraToggle.Text = "Kill Aura: " .. (isKillAura and "B·∫¨T" or "T·∫ÆT")
    
    local rangeText = killAuraRangeInput.Text
    local newRange = tonumber(rangeText)
    if newRange then
        killAuraRange = math.clamp(newRange, 1, 100)
        notify("T·∫ßm xa Kill Aura ƒë√£ ƒë·∫∑t: " .. killAuraRange)
    else
        killAuraRange = 20
        notify("S·ª≠ d·ª•ng t·∫ßm xa m·∫∑c ƒë·ªãnh: 20")
    end
    
    if isKillAura then
        killAuraConnection = RunService.Heartbeat:Connect(function()
            if character and rootPart and humanoid then
                pcall(function()
                    for _, obj in pairs(workspace:GetDescendants()) do
                        if obj:IsA("Humanoid") and obj ~= humanoid and obj.Parent and not Players:GetPlayerFromCharacter(obj.Parent) then
                            local enemyRoot = obj.Parent:FindFirstChild("HumanoidRootPart") or obj.Parent:FindFirstChildWhichIsA("BasePart")
                            if enemyRoot then
                                local distance = (rootPart.Position - enemyRoot.Position).Magnitude
                                if distance <= killAuraRange then
                                    obj.Health = 0
                                    task.wait(math.random(0.05, 0.15))
                                end
                            end
                        end
                    end
                end)
            end
        end)
        notify("ƒê√£ b·∫≠t Kill Aura v·ªõi t·∫ßm xa: " .. killAuraRange)
    else
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        notify("ƒê√£ t·∫Øt Kill Aura")
    end
end)
nearestChestButton.MouseButton1Click:Connect(function()
    local success, result = pcall(function()
        local chests = {}
        for _, obj in pairs(workspace:GetDescendants()) do
            if obj:IsA("Model") or obj:IsA("BasePart") then
                if obj.Name:lower():find("chest") or obj.Name:lower():find("crate") or obj.Name:lower():find("box") then
                    local chestPos = obj:FindFirstChildWhichIsA("BasePart") or obj
                    if chestPos then
                        table.insert(chests, chestPos)
                    end
                end
            end
        end
        
        if #chests == 0 then
            notify("Kh√¥ng t√¨m th·∫•y r∆∞∆°ng n√†o!")
            return
        end
        
        local nearestChest = nil
        local minDistance = math.huge
        for _, chest in pairs(chests) do
            local distance = (rootPart.Position - chest.Position).Magnitude
            if distance < minDistance then
                minDistance = distance
                nearestChest = chest
            end
        end
        
        if nearestChest then
            if minDistance > 5000 then
                notify("Kho·∫£ng c√°ch ƒë·∫øn r∆∞∆°ng qu√° xa!")
                return
            end
            rootPart.CFrame = nearestChest.CFrame + Vector3.new(0, 3, 0)
            task.wait(math.random(0.2, 0.5))
            notify("ƒê√£ d·ªãch chuy·ªÉn ƒë·∫øn r∆∞∆°ng g·∫ßn nh·∫•t!")
        else
            notify("Kh√¥ng t√¨m th·∫•y r∆∞∆°ng g·∫ßn!")
        end
    end)
    if not success then
        notify("L·ªói khi d·ªãch ƒë·∫øn r∆∞∆°ng: " .. tostring(result))
    end
end)
player.CharacterAdded:Connect(function(newCharacter)
    character = newCharacter
    humanoid = character:WaitForChild("Humanoid", 5)
    rootPart = character:WaitForChild("HumanoidRootPart", 5)
    
    if not humanoid or not rootPart then
        warn("Kh√¥ng t√¨m th·∫•y Humanoid ho·∫∑c HumanoidRootPart sau khi reset!")
        return
    end
    
    if isNoClip then
        pcall(function()
            for _, part in pairs(character:GetDescendants()) do
                if part:IsA("BasePart") then
                    part.CanCollide = false
                end
            end
        end)
    end
    
    if isInfiniteJump then
        if infiniteJumpConnection then
            infiniteJumpConnection:Disconnect()
            infiniteJumpConnection = nil
        end
        infiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
            if character and humanoid then
                pcall(function()
                    humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
                    task.wait(math.random(0.1, 0.2))
                end)
            end
        end)
    end
    
    if isKillAura then
        if killAuraConnection then
            killAuraConnection:Disconnect()
            killAuraConnection = nil
        end
        killAuraConnection = RunService.Heartbeat:Connect(function()
            if character and rootPart and humanoid then
                pcall(function()
                    for _, obj in pairs(workspace:GetDescendants()) do
                        if obj:IsA("Humanoid") and obj ~= humanoid and obj.Parent and not Players:GetPlayerFromCharacter(obj.Parent) then
                            local enemyRoot = obj.Parent:FindFirstChild("HumanoidRootPart") or obj.Parent:FindFirstChildWhichIsA("BasePart")
                            if enemyRoot then
                                local distance = (rootPart.Position - enemyRoot.Position).Magnitude
                                if distance <= killAuraRange then
                                    obj.Health = 0
                                    task.wait(math.random(0.05, 0.15))
                                end
                            end
                        end
                    end
                end)
            end
        end)
    end
end)
local dragging = false
local dragStart = nil
local startPos = nil

toggleButton.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch then
        dragging = true
        dragStart = input.Position
        startPos = toggleButton.Position
        input.Changed:Connect(function()
            if input.UserInputState == Enum.UserInputState.End then
                dragging = false
            end
        end)
    end
end)

toggleButton.InputChanged:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.Touch and dragging then
        local delta = input.Position - dragStart
        toggleButton.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end
end)
